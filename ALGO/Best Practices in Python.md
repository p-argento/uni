## LIsts vs Sets
Set are much faster.
Sets can be used to return multiple values from a function. Even different types.
## Unpacking Tuples
Common use of unpacking is returning multiple values from a function.
a, b, c are assigned to the first, second and third element of the tuple.
The number of variables must equal the length of the tuple.
```python
tup = ("hello", [1, 2, 3], 42)
a, b, c = tup
print(a, b, c, sep='\n')
# a, b = tup WRONG
```

 THIS is the Python way to swap (idiomatic)
```python
a, b = b, a
```
On the right we create a tuple and we use unpacking to assign on the left.
## Use of Underscore
To indicate that you are not interested in that value.
If you save a value, someone will look for the code where you use that variable. So, if you will not use it, just use `_`.
Also the use of `*_` is very interesting, it means "as many _ as needed"

```python
# Not interested in some elements? Use the placeholder _
_, b, _ = tup

print(b)

# Not interested to last elements? Use *_, which means "as many _ as needed"
a, *_ = tup
print(a)

# Guess what
a, *rest = tup
print(rest)
```

## Why do we use immutable objects?[¶](http://localhost:8888/lab/tree/L02-Python-DataStructures.ipynb#Why-do-we-use-immutable-objects?)

- Immutable objects are **thread-safe** (means being able to run on multiple code at the same time) so you will not have any synchronization issues.
- It is guaranteed that functions or classes cannot modify the object.
- Immutable object are easier to cache.
- The internal state of your program will be consistent even if you have exceptions.
- Immutable objects are good Dictionary keys and Set elements. Have you ever ask yourself why a list cannot be a key in a dictionary?

**Immutability can have a performance cost**, since when an object cannot be mutated we need to copy it if we want to write to it.

## Text of strings
Create a text of strings.
Be aware of the difference in terms of efficiency between two methods.
First, the append way is quadratic because it
Second, the join way is linear because first sele

```python

text = "\n".join(strings)
```

## Initializing a list of lists
Everyone expect the same type in a list.
Otherwise it is very error prone.

Note that multiplying a list of a list by n creates copies of the lists, meaning that they are shallow copies. But I can still inizialize different lists when initializing the list containing the others, for example with a for loop.
So, for creating a table made by lists:

```python
l = [ [] ] * 10 # wrong

for _ in range(10): # correct
	l.append([])
```

## Generate vs Materialize
Python always tries to generate when possible.
Generate is easier in terms of memory.

Never iterate over the position if you can iterate over the elements.
It is less error prone and much more clear.
Also because of reusability of code with objects that do not have indexes, like sets or generators.

> This is the second most important lesson, after not using "in" in loops.

Enumerate generates pairs position-value.
The sequence of pairs is generated by an object, but not materialized.
It can be generated using `list(enumerate(l))`, but it is not what you usually do, because it is used to iterate over it.

```python
# sum of even numbers in the CORRECT way
s = 0
for i,e in enumerate(l):
	if i % 2 == 0:
		s += e
# the WRONG alternative is
s = 0
for i in range(len(l)):
	if i % 2 == 0:
		s += l[i]
```

> Do a lot of exercises using more advanced stuff.
> Otherwise you will not be expert enough in python.

## Modifying a list
Append and extend take constant time.
Insert, pop and remove take linear time, and should be used very carefully.
Popping the last element, however is pretty efficient.

List comprehensions allow to filter out from a list.

> At the beginning of a task, stop and explain yourself the task using the right terminology.

**The rule** is easy: The variable is a cell that contains the value or a reference to the object. We copy the content of the variable. Variables of most of types contain a reference (a pointer) to the object, which is stored somewhere else in memory.
**Ratio for the rule**: avoid expensive copies as much as possible.

The last element of the list is `l[-1]` because it is like `l[len(l) - 1]`.
And so on with `-2,-3` and so on.





