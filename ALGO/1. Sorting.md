## The Sorting Problem
Input: sequence `A[1,n]` of n elements
Goal: permutation `A'[1,n]` of A (without creating a new element) such that $$A'[i]\leq A'[i+1]\qquad\forall i\in[1,n-1]$$
All the books about algorithms are 1-based (NOT 0-based like python).
Keep this in mind when turning pseudo-code into real-code.

What is the idea for ordering a vector?
Never use an external number to replace a number which was supposed to be removed. It is a patch and it is wrong.
Swap the number to be removed with the last one and remove the last one.

> Try to implement a sorting algorithm with the min.

Instead of creating a new array, it is a better idea to divide the array in sorted and unsorted sub-arrays. Each time a min is computed, the number goes to the left and the index of the unsorted sub-array is increased by 1 (started from 0).
This algorithm is called *selection sort*.

Iterating the array n times and swapping each time the consecutive element if smaller. It is called *bubble sort*. Never use this, it is one of the worst.

Another approach is place each number in its correct position. Start with a one-number array and increasingly add items in the right position.
This is 

Which one is the best?
> Try to implement this in python.


--- 21.02 ---

>The complexity of an algorithm is the number of steps required in order to find a solution.

## Insertion Sort
It is an "inplace sort", meaning that modifies the original array.
It doesn't need extra space for creating a new array.
We process the array and when the i-th term is not sorted, it will be moved backwards to its correct position, comparing with each antecedent until we found the smaller or equal.

Pseudocode.
i is the antecedent, j is the item to be moved.
```pseudocode
InsertionSort(A)
	for j=2 to length
		key = A[j]
		// insert key in already sorted A[1,i-1]
		i = j - 1
		while i > 0 and A[i] > key
			A[i+1] = A[i]
			i = i - 1
		A[i+1] = key
```

> Always simulate. Design an example and run the algorithm step by step.
> I strongly encourage you to try more examples.

Running Example.
> Do not believe in comments


Let's prove the *correctness of this algorithm*.
There are no automatic tools to check correctness,  we must use a proof.
"unit testing" means defining some examples, especially with marginal cases like empty array.
The larger the set for testing is, the better is the confidence in the correctness of the algorithm.

## Loop invariant
Idea
1. find a property which is valid for every iteration of the algorithm.
2. using this property you should be able to check correctness.
3. the goal is to prove that after the loop the array is sorted.
Definitions
1. loop invariant: a property that holds for every iteration of the algorithm
2. initialization: the property holds before the loop starts
3. maintenance: the property holds after every iteration
4. termination: the property holds after the loop terminates

*Loop invariant for Insertion Sort*
At iteration j, `A[1,...,j-1]` is sorted.

## Stability
Idea
1. if we look at the array before and after being sorted, and we focus on different occurrences of the same values, then those occurrences *preserve their relative order*
	1. $...n_1...n_2...n_3... \rightarrow ...n_1n_2n_3...$

## Analysis of Algorithm
What does it mean? It means finding a mathematical formula which is able to tell us how many steps the algorithm requires. What does a step mean?
We need to agree on a *computer model* that should be
1. simple enough to make analysis possible
2. precise enough to give meaningful analysis
There a lot of computational models, each one analysing a different aspect like memory. We focus on the easiest, which is called RAM Model.
It allows to remove algorithms that are very inefficient. But to compare two algorithms that looks efficient, the only way is testing.

*Ram Model*
CPU takes data from a memory. Afterwards the result will be stored again in mamory.
In our model, all the operations have the same cost (like sum and square root) and access from memory has always the same cost. But in real life this is far from being true.
Then, there are registers (increasingly bigger):
1. CPU registers of memory
2. L1 cache (KB)
3. L2 cache (MB)
4. L3 cache (MB)
5. RAM (GB)
6. Disks (TB)
Accessing data in different registers costs differently, increasingly more expensive.
CPU performs operations between (at most 2) values in memory and saves the result back in memory.

What are the *operation* the CPU is allowed to perform?
Set of elementary operations: $+, -, *, /, \sqrt{}, log, \lceil\ \rceil, \lfloor\ \rfloor, and, or$
The cost of any operations is 1.
But remember that this is irrealistic because $\sqrt{}$  cost is much more than $+$
### Analyzing Insertion Sort
*Constant* means independent of the size of the input. But depends on the machine.
How many times are we executing every constant instruction?
In general, we evaluate a loop condition one time more (when we stop and do not enter the loop).
f(n) is the worst case , among all possible inputs, meaning the worst possible input for the algorithm.
Remember that this type of analysis can be problematic, because most cases can be actually efficient, and the worst case can be marginal.

The magic formula is $cost\times times$
But cost is constant, meaning that depends on the computer.

> try to calculate the f(x) of insertion sort for some arrays. What is the best case? What is the worst case?











