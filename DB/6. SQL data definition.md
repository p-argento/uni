SQL is not just a query language, but is also language for the definition of databases (Datadefinition language (DDL)) 
1. CREATE SCHEMA
2. CREATE TABLE
3. CREATE VIEW
4. CREATE INDEX, a data structure to access faster the table
5. CREATE PROCEDURE
6. CREATE TRIGGER, code automatically executed whenever a condition is met
7. GRANT.

```sql
CREATE TABLE Employees (
	Code CHAR(8) NOT NULL, --null allowed by default
	Name CHAR(20),
	Birthyear INTEGER CHECK (Birthyear < 2005),
	Qualification CHAR(20) DEFAULT ‘Employee’,
	Supervisor CHAR(8),
	PRIMARY KEY pk_ Employees (Code),
	FOREIGN KEY fk_ Employees (Supervisor)
	REFERENCES Employees ) 
	
CREATE TABLE Dependents (  
	Name CHAR(20), 
	Birthyear INTEGER, 
	EmployeeCode CHAR(8), 
	FOREIGN KEY fk_ Dependents (EmployeeCode) 
	REFERENCES Employees )
```

Why CHECK ?
Whenever a constraint is violated, a failure is raised.  
If a transaction is aborted, it eliminates all the effects of this transaction
The check is centralized in the schema.  And not checked after using a script.  
However, usually there is an additional gui check preventing the user from even trying adding wrong data.

a primary key is mandatory only if there is a foreign key for which the pk is the target

What you create with a CREATE can be deleted with the DROP command or modified with the ALTER command.

## Views
MATERIALIZED VIEW: create a table as a result of a query .
BUT note if the main table changes, you need to run again the query (also using a trigger)

the view is much better than the materialized view,  
in rare cases with many calls on the same virtual table, it might make sense to materialize it while making the specific queries,

```sql
CREATE VIEW Supervisors 
	AS  SELECT Code, Name, Qualification, Salary 
		FROM Employees 
		WHERE Supervisor IS NULL
```
