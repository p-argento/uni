
Vediamo gli operatori per la ricerca di dati.
## Clausola SELECT
Con il comando SELECT si possono calcolare tabelle le cui colonne non corrispondono a colonne delle tabelle selezionate, ma sono ottenute come espressioni a partire da attributi e costanti. Ad esempio:
```sql
SELECT CodiceAgente, Nome, Commissione / 100 AS Commissione, ‘Italia’ AS Paese 
FROM Agenti
```
restituisce una tabella con tante righe quanti sono gli agenti, e con quattro colonne, due ottenute per proiezione dalla tabella Agenti, una con valori calcolati da un’altra colonna, ed una formata da valori costanti.

Un’espressione SELECT può apparire nella condizione, come vedremo, e viene detta SottoSelect o SELECT annidata.
## Clausola FROM

le clausole USING e ON si possono usare solo con l’operatore JOIN. 
Il significato è il seguente: 
1. CROSS JOIN e “,” corrispondono all’operatore di prodotto cartesiano; nella nota- zione moderna si preferisce l’uso dell’operatore CROSS JOIN; 
2. NATURAL JOIN è la giunzione naturale; 
3. JOIN . . . USING è la giunzione sui valori uguali degli attributi specificati e presenti in entrambe le tabelle, in generale un sottoinsieme degli attributi con lo stesso nome presenti in entrambe le tabelle;
4. JOIN . . . ON è la giunzione sui valori degli attributi che soddisfano una generica condizione;

## Clausola WHERE

...


## ORDER BY
Clausola di ordinamento


## Funzioni di aggregazione (o statistiche)
Quando si usano le funzioni di aggregazione nella SELECT, il risultato deve essere un’unica ennupla di valori e quindi si possono usare più funzioni di aggregazione, ma non si possono usare funzioni di aggregazione e attributi, se non nel caso descritto nella prossima sezione. Ad esempio, è scorretto scrivere: 
```SQL
SELECT NumOrdine, MIN(Ammontare), MAX(Ammontare) 
FROM Ordini 
WHERE Data = ‘01032019’;
```

## GROUP BY
Il comando SELECT con il GROUP BY ha la seguente struttura: 
```sql
SELECT  
DISTINCT SA, SFA 
FROM T 
WHERE WC 
GROUP BY GA 
HAVING HC 
ORDER BY OA;
```

Ad esempio, per trovare il codice e nome degli agenti con più di cinque ordini in data 1/3/2019 e, degli ordini fatti, il totale e la media dell’ammontare, si pone: 
```sql
SELECT  A.CodiceAgente, A.Nome, SUM(Ammontare), AVG(Ammontare)
FROM  Ordini O JOIN Agenti A ON A.CodiceAgente = O.CodiceAgente 
WHERE  O.Data = ’01032019’ 
GROUP BY O.CodiceAgente, A.Nome 
HAVING  COUNT(∗) > 5; 
```
Si osservi che due agenti con lo stesso codice hanno anche lo stesso nome, per cui raggruppare rispetto a CodiceAgente, Nome equivale a raggruppare rispetto al solo codice. Tuttavia, se si raggruppasse solo rispetto al codice, il sistema non permetterebbe poi di selezionare il campo Nome.

Never GROUP BY functions.

## Exercise in class

[[SQL exercise 1903]]

## NULL

What happens to the AND, OR and NOT operators? • A 3-value logic is needed (true, false and unknown).
NULL belongs to every type, so even booleans have the NULL option.
It means that if there is a NULL in a comparison, the result is NULL.

*No value is equal to NULL, because NULL is not equal to NULL.*
We need a special operator which is ISNULL. It distinguish NULL from TRUE and FALSE.

> Understand better this 3-value logic.

In aggregate functions like COUNT and AVG, the NULL values are ignored.

GROUP BY does not respect the NULL.
All NULL are put in the same group, even though they are not equal.
But here it is more useful to group them.


...

## Existential Quantification
Existential quantification can be expressed using:
- Exists (the most expressive) 
- Join
- =Any, >Any, <Any…
- IN 

Note that =Any, >Any, <Any, IN,… do not add any expressive power, one may just use EXISTS


## Universal quantification

> Whenever in doubt, it is usually existential, say 95% of the time.

